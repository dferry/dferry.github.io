<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>

<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1"><title>CSCI 3500 - Operating Systems</title></head>

<h2 style="text-align: center;">CSCI 3500: Studio 3<br></h2>
<h2 style="text-align: center;">Pointers</h2>

<hr style="width: 100%; height: 2px;">


<p>One tricky part of writing good C code is using pointers
correctly. Understanding how pointers work, how to use them to index arrays, how they relate to strings,
and how to reference and dereference data correctly is vital.</p>

<p>In this studio, you will:</p>

<ol>
  <li>Learn about pointers and strings in C
  <li>Use pointers to index into an array
  <li>Write some basic string manipulation functions
</ol>

<hr style="width: 100%; height: 2px;"><p>
<p>
Please complete the required exercises below, as well as any optional
enrichment exercises that you wish to complete.</p> 

<p>
As you work through these exercises, please record your answers in a text
file. When finished, submit your work via the git repository.
<!--by sending your text file and
source code to <strong>dferry_submit@slu.edu</strong>
with the phrase <strong>
Pointers
</strong> in the subject line.</p>-->

<p><strong> Make sure that the name of each person who worked on these exercises
is listed in the first answer, and make sure you number each of your responses
so it is easy to match your responses with each exercise.</strong></p>
<hr style="width: 100%; height: 2px;"><p>

<p><h3>Required Exercises</h3></p>

<ol>
<p><li>As the answer to the first exercise, list the names of the people who
worked together on this studio.</p>

<p><li> Let's start by building a minimal program. Look at the
programs from the previous studios, and write out a main function. Inside
your function you should only have the statement "<code>return 0;</code>"
This is a valid C program, though it doesn't do much. When it runs
it will immediately quit and return zero to the terminal. </p>

<p>(You don't
see the zero, but any command you run through the terminal
returns some value and you can get that value if you want.
By convention in Linux/Unix a return value of zero indicates
that the program ran successfully, while any non-zero value
indicates an error. These return values
are especially useful for scripting a set of commands in sequence,
as they tell you whether or not each step was successful and allow
you to react appropriately. Typing the command
"<code>echo $?</code>" will show the return value of the last command
executed. You can try this now if you want- remember the program
"<code>cat</code>" prints a file to the terminal, so if you use <code>cat</code>
with a real file that exists you should get a return value of zero, while
if you use the command "<code>cat FileDoesNotExist</code>" you should get
some non-zero return value. You can also try returning different
values from your program as well. But I digress- this is not the purpose of this
studio, but still good for any Linux programmer to know.)</p>

<p>Make sure your code compiles successfully. Remember we use the GCC
compiler to build C programs. If you have named your program
<code>pointers.c</code> then you can use a command such as
<code>gcc -Wall pointers.c -o pointers</code> to build your
code. You can leave this answer blank.</p>

<p><li>Now back to pointers. Pointers are an essential part of programming in C, and one of the
biggest things we use them for is accessing arrays. We can have arrays of
any data type: chars, ints, floats, doubles, and so on. Copy the following
line into your <code>main()</code> function.</p>

<p><code>char *messagePtr = "HELLOWORLD!"</code></p>

<p>Let's break down this statement. There are several important pieces.
<ol>
	<p><li><i>messagePtr</i> - This is the name of a variable we have just defined.</p>
	<p><li><i>The asterisk</i> - Declares that <code>messagePtr</code> is a pointer.</p>
	<p><li><i>char</i> - This declares that <code>messagePtr</code> is a pointer
to a <code>char</code>. Remember that a <code>char</code> is a one-byte data type.</p>
	<p><li><i>"HELLOWORLD!"</i> - This is the string that the variable 
<code>messagePtr</code> points to, called a <i>string literal</i>. </p>
</ol>


<p>Next, let's print this string just to make sure everything
is working correctly. Observe that the <code>%s</code> format specifier
tells <code>printf()</code> to print a string.</p>

<p><code>printf("%s\n", messagePtr);</code></p>

<p>You will also need to include <code>stdio.h</code> at the top of your file.</p>

<p>You can leave the answer to this question blank.</p>


<p><li>We can access the elements of a string by <i>dereferencing</i> the string pointer. A pointer
points to data in memory, and dereferencing that pointer gives us the
<i>value</i> of the data. The simplest way to dereference is through the use
of the square bracket <i>index notation</i>. The code
<code>messagePtr[0]</code> gives you the first character "H", 
the code <code>messagePtr[1]</code> gives you the
second character "E", etc.</p>

<p>Print out each character of the string using a for-loop with
index notation. You can print a character as such: "<code>printf("%c\n", char_to_print)</code>.
Your output should look like:</p>
<pre>
H
E
L
L
O
W
O
R
L
D
!
</pre>

<p>As the answer to this question, copy-paste your for-loop.</p>

<p><li>The <i>dereference operator</i> in C is the asterisk (<code>*</code>) 
and is also important when using pointers. 
Just like indexing a pointer, the dereference operator obtains the 
<i>value</i> of the data that is pointed to.</p>

<p>If the pointer <code>messagePtr</code> is a pointer to a
character, what character does it point to? In other words, what 
do you think is the value
of the dereference operation <code>*messagePtr</code>?</p>

<p><li>Check your answer to the last exercise by dereferencing
<code>messagePtr</code> and printing it out. The dereference operator is the
asterisk when placed to the left of a pointer. You can print out a single
character like so:</p>

<p><code>printf("%c\n", *pointer_to_string);</code></p>

<p>What was printed?</p>

<p><li>Another way to use pointers is with <i>pointer arithmetic</i>.
Suppose we have a regular string pointer called <i>ptr</i>,
as seen above this points to the first character of the string. To
access the next character we could add to this pointer as such:</p>

<p><code>ptr + 1  //same as saying ptr[1]</code></p>

<p>or we could access the fourth element of the string by adding:</p>

<p><code>ptr + 3  //accesses fourth element, same as ptr[3]</code></p>

<p>The index notation you just used is essentially pointer arithmetic 
(in fact the C standard defines index notation in terms of pointer
arithmetic).</p>

<p>Try printing the value of the next few bytes of the string using
pointer arithmetic. To do so, add one, two, or three to the pointer before 
dereferencing. For example: <code>*(messagePtr + 1)</code>.</p>

<p><li>Write a second for-loop to 
print the entire contents of the string using pointer arithmetic,
one character at a time. As the answer to this question, copy and
paste your new for-loop.
</p>

<p><li>It's easy to use pointers with strings when we know exactly what
the string is. It's harder when we don't. For example, how did you
figure out how many iterations of the for-loop you needed for the
previous exercises? If you're like most of us, you just counted
out the eleven characters in "HELLOWORLD!". So, how do we handle arbitrary
strings?

<p>Recall that in a properly formatted C-style string the string
	pointer indicates the first character of the string and always
	ends with a <i>null-terminator</i> (ends with the character '\0'). 
	See the diagram below.</p>

<img src="pointers.PNG" alt="A diagram of the string in memory. There are
	  twelve consecutive bytes, starting with H, E, L, L, O and
	  continuing. The eleventh byte is the exclamation point, and the
	  twelfth byte is the NULL terminator."/>

<p>We can always use the null-terminator to know when a string ends.
For this exercise I want you to print the string using a while loop
instead of a for-loop. Use the fact that the string ends with a null
value as your loop condition. You can use the keyword <code>NULL</code>
or the null character <code>'\0'</code> to compare against. As the answer
to this question copy-paste your while loop.</p>

<p><li>It's also important to understand how pointers are treated when
	calling functions. Recall that the two basic ways to pass arguments to
	functions are <i>pass-by-value</i> and <i>pass-by-reference</i>.
	The C language does not support pass-by-reference, and everything
	is passed by value. So for example, you can't pass a string
	to a function.</p>

<p>Suppose we want to write a function that uses strings- what can we do instead?
The answer is to pass a pointer to the function- we can pass a pointer by value,
and that pointer can point to a string. Copy the following function definition
above your <code>main()</code> function:</p>

<pre>
void printReverse( char* string ){

}
</pre>

<p>Starting with your code from the previous exercise, write a function
that prints a string in reverse order. For example, printing the
string pointed to by <code>messagePtr</code> should produce the output:</p>

<pre>
!
D
L
R
O
W
O
L
L
E
H
</pre>

<p>You should not make any assumptions about the string passed to the function.
Use the fact that strings are always null-terminated to figure out how long
the string is. (Do not use the C-standard library function strlen()- get the
value yourself.)
Your code should work equally well with <code>messagePtr</code>
or with another string such as:</p>

<p><code>char *secondString = "Another string!";</code></p>

<p>As the answer to this exercise, copy-paste your function.</p>


<p><li>For our last exercise today, we will write a second function that 
creates a reversed copy of an input string. Feel free to borrow code
from any of the other exercises you've done today. Start with the following outline.
This code should also go above your <code>main()</code> function.</p>

<pre>
#include &lt;stdlib.h&gt;

char* reverseString( char* input ){

//1. First count how many characters are in the input string

//This creates enough space to store the reversed string, plus one more byte
//for the null terminator
char* output = (char*)malloc( number_of_chars_in_input+1 );

//2. Copy the input string to the output string in reverse order. There are
//multiple ways to do this- consider using a counter, or consider using two
//pointers. 

//REMEMBER THAT YOUR OUTPUT STRING MUST END WITH A NULL TERMINATOR. This is not
//provided for you automatically- you must put it there!

	return output; 
}
</pre>

<p>The above code bears some explanation. Look up the function <code>malloc()</code>
in the manual pages. This function takes a number and returns a pointer to a region
of memory with that many bytes. For example, <code>malloc(10)</code> returns
a pointer to a region of memory with 10 bytes that you can modify
however you'd like. This is necessary because we need someplace to
<i>put</i> our reversed string. Then, the last line returns that pointer
so it can be used.</p>

<p>Verify your function works with the following code in your main function:</p>

<pre>
char* reversedMessage = reverseString( messagePtr );
printf("Reversed string: %s\n", reversedMessage);
</pre>

<p>As the answer to this exercise, copy-paste your last function.</p>

	<!--
<p><code>int numbers[] = { 4, 8, 15, 16, 23, 42 };</code></p>
<p><li>Lastly, one thing to keep in mind is how the <i>pointer type</i>
interacts with pointer arithmetic. First, let's figure out how big a given data
type is, in bytes, using the special <code>sizeof()</code> command in C. The
<code>sizeof()</code> command will return the number of bytes in a data type,
for example:</p>

<p><code>sizeof( char ) //returns 1</code></p>

<p>Write a short segment of code to print out the size of the <code>char</code>
data type and the <code>int</code> data type.</p>

<p><li>Pointer arithmetic is actually based on these data type sizes. If you
have a pointer to an integer then the associated size is four bytes. So the
statement <code>pointer[2]</code> is actually doing the computation:</p>

<p><code>pointer + 2*sizeof(int) = pointer + 2*4 bytes = pointer + 8 bytes</code></p>

<p>We can check this for ourselves directly. Declare a pointer to the
first and third elements of the <i>numbers</i> array, as such:</p>

<pre>
int *first = numbers;
int *third = &(numbers[2]);
</pre>

<p>Now, print out these two pointers with the <code>%p</code> format
specifier. What is the difference between them? Note that the values
are displayed in hexadecimal.</p>

<p><li>Lastly, explain the declaration of the pointer called <code>third</code>
above. What does the ampersand operator do?</p>
-->
</ol>




<p><h3>Optional Enrichment Exercises</h3></p>
<ol>
	<p><li>None.</p>
<!--
	<p><li>As has been said a few times already, pointers simply point to 
data that resides in memory. Here's an experiment to convince you
of this, if you don't believe me already.</p>

<p>Open up your compiled executable file in a text editor. You will see a lot
of gibberish but you'll also see a few recognizable things. Use the search
function of your editor to search for the strings <code>"Linux!"</code> and
<code>"Windows!"</code>. Can you find them?</p>

<p>Now, being slightly careful, use your text editor to change 
<code>Windows!</code> to <code>Solaris!</code> and save the file. What happens
when you re-run the program?</p>

<p><i>Note: This is not the advisable way to modify a program!</i></p>
-->

</ol>

<hr style="width: 100%; height: 2px;"><p>
